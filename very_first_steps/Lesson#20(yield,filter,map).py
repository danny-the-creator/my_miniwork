# yield
# Это оператор, учавствующий в генераторах (не списков)

def countdown(n):                   # !!! Это не генератор
    result = []
    while n != 0:                   # Функция считает от 10 до 0 и вносит это всё во временное место хранения 'result'
        n -= 1
        result.append(n)
    return result                   # Возвращает 'result', в котором уже ВСЕ элементы
# print(countdown(5))

# Генератор выполняет тоже самое, но возвращает результат частями и не имеет временного хранения
def gen_countdown(n):
    while n != 0:
        n -= 1
        yield n
# print(gen_countdown(10))                # В данном случае будет выведен не результат, а сам генератор
gen = gen_countdown(5)
# print(next(gen))                        # next() выдаёт следующий элемент генератора (она неявно используется в циклах, так что ничего нового)
# print(next(gen))                        # Но генератор не забывает полностью свою локальную область видимости
# print(next(gen))                        # И он будет выводить частями результат: при 1 вызове - 4, при 2 - 3, при 3 - 2 и тд
# print(next(gen))                        # Формально, генератор не завершает свою работу, он лишь возвращает временный контроль коду, пока к генератору не обратятся ещё раз

hello = "Hello"                         # Рандомный код не имеющий никакого отношения к генератору
world = ['W','o','r','l','d']
result = f'{hello} {"".join(world)}!'
# print(result)

# print(next(gen))                        # Если между вызовом генератора появится другой кусок кода, он будет выполнен без изменений
# print(next(gen))                        # При попытке вывести следующий элемент, после окончания работы генератора он Выведет ОШИБКУ,
                                                                                                                        # а не начнёт с начала, как это бы сделала функция
# for i in gen_countdown(5):                # генераторы можно (и скорее всего нужно) использовать в цикле
#     print(i)
# print(tuple(gen_countdown(10)))           # генератор можно сразу превратить в список, но тогда теряется его смысл, ведь он превращается в функцию

# n = 0                                     # Пример использования генератора
# for i in gen_countdown(1000000000000000000000000000000000000):          # из просто гигантского генератора, нам нужны всего первые 100 элементов
#     print(i)                                                            # и генератор не тратит ни памяти, ни времени на подгрузку всего списка
#     n+=1                                                                # а выводит его элементы постепенно,
#     if n == 100:                                                        # и после сотни выводов заканчивает свою работу
#         break

# gen = gen_countdown(1000000000000000000000000000000000000)                # это аналог цикла выше
# for i in range(100):
#     print(next(gen))


# Filter

# filter(func, iterable)                    # Функция 'filter' принимает функцию, которая является критерием фильтровки (ниже пример) и список или любой другой
                                                                                                                                    # итерируемый объект (чаще всего список)
# Пример функции, которая может являться критерием фильтровки для функции 'filter'
def has_number(string):                                             # Функция проверяет есть ли какое-то число в строке
    for number in {'0','1','2','3','4','5','6','7','8','9'}:
        if number in string:                                        # Если да, то сразу возвращается bool -> True
            return True
    return False                                                    # Если в строке не оказалось ни одного числа, возвращает bool -> False

#! Примечание: Возвращаться должно обязательно булевское выражение (True/False)

list_ = ['1555', 'fffffgghn', 'one', 'the 1-st', '№33', '100 points', 'five %', '99%', 'Hello']
filter = filter(has_number, list_)
# print(filter)                                                       # 'filter' не возвращает отфильтрованный список, она возвращает фильтр как объект
# print(list(filter))                                                                             # Однако это не так тяжело исправить, можно просто обернуть фильтра в список

# Анологично можно записать ввиде генератора списка
# print([str for str in list_ if has_number(str)])      # Поэтому использовать 'filter' не всегда стоит, к примеру если нужно получить список, лучше использовать генератор списков,
                                                        # а если нужен сам итерратор ( <filter object> ), то функция 'filter()' будет более уместна
# Тоесть данные из 'filter' можно получать постепенно как и из генератора
# print(next(filter))
# print(next(filter))
# print(next(filter))


# Подробнее о функции MAP   (map())

# map(func, *iterable)                                  # map принимает функцию и итерируемый объект (а может и несколько, но чаще всего один) чаще всего ввиде списка
                                                                                    # функция, которую мы введём, будет применина ко всем объектам списка
def Capitalize(str):                                            # Пример функции, которая будет применяться к строкам в 'maplist'
    return str.capitalize()

maplist = ['234567FhhffjfDK','RTjjgfjHGFHFjgfg','ffffhhh','Ifghjkl','FGHJ','RjkkjGTFHJ','ghukKOHG']

new_maplist = map(Capitalize, maplist)
# print(new_maplist)                                              # 'map()' возвращает итерируемый объект
# print(list(new_maplist))                                        # Переводит функцию 'map()' в список

# Функция MAP как и filter, как и генератор можно представить в виде функции с 'yield'

# Аналого функции map() через yield:
def map(func, iterable):                                        # функция принимает функцию и список
    for i in iterable:                                          # и для каждого элемента в списке
        yield func(i)                                           # применяет к нему функцию и возвращает результат

# Это означает, что из map, как и из filter можно получать данные постепенно
# print(next(new_maplist))                                      # Стоит помнить, что на это расходуется элемент результата функции map
# print(next(new_maplist))                                      # И если после этих двух print-ов запустить цикл, то...
# print('--------------------------------------')

# Также её можно запустить в цикле
# for i in new_maplist:                                           # ... из него выведется только остаток
#     print(i)

# Конечно вместо обычной функции можно использовать и lambda функции
maplist_2 = map(lambda str: str.capitalize(), maplist )
# print(list(maplist_2))

# Но функцию 'map' стоит использовать, когда нам нужен не список, а итератор
# Если нам нужен сам список, легче быстрее и правильнее будет использовать генератора списков (разница как с обычным генератором и генератором списка в области их применения)

# Тоже самое, но через генератор списка
list_gen = [i.capitalize() for i in maplist]
# print(list_gen)

# !!! Напоминание !!!
# Иногда легче и правильнее использовать генератор списка, а иногда map() и filter()
# Всё зависит от ситуации