# Декораторы
from datetime import datetime
# Пример: Обе функции выводят число(n) в 10 степени, но одна из них вычисляет результат как 'n*n*n*n*n*n*n*n*n*n', а вторая как 'n**10'
                                                                                # Цель: понять на какую операцию уходит больше времени
def one():
    # start = datetime.now()                                                      # Но это не относится к результату функции, а лишь замеряет время
    result = [n*n*n*n*n*n*n*n*n*n for n in range(10000) if n % 5 == 0]
    # print(datetime.now() - start)                                               # Как и эта строка, Это не хорошо
    return result

def two(i):
    # start = datetime.now()                                                      # И здесь тоже получается некрасивая функция
    result = [n**10 for n in range(i) if n % 5 == 0]
    # print(datetime.now() - start)                                               # И ещё одна строка, которая не относится к функции, и это замерение надо будет добавлять
    return result                                                                                                                        # ко всем функциям, а если их 100?

# print(one(5234561234567))
# print(two(5234561234567))

# Удобно было бы заключить эту функцию в скобки, которые бы и выполнили один и тот же код вокруг схожих функций
# К примеру: замерь_время_выполнения(function) или timein(function)

# !!! ДЕКОРАТОРЫ позволяют это реализовать! !!!

# def timein(func):                               # Функция декоратора
#     def wrapper():                              # Его вложенная функция
#         start = datetime.now()                      # часть отвечающая за подсчёт времени выполнения функции
#         result = func()                                         # выполнение самой функции, которую мы оборачиваем декоратором
#         print(datetime.now() - start)               # часть отвечающая за подсчёт времени выполнения функции
#         return result
#     return wrapper                              # возвращает саму функцию (пример замыкания)  !(timein(func) == wrapper())

# wrp1 = timein(one)                          # мы вызываем декоратор, передаём ему функцию, которую будем использовать и записываем в переменную
# print(wrp1)                                 # Но так ка timein() возвращает wrapper (саму функцию), то и наша переменная становится функцией
# print(wrp1())                               # Теперь мы вызываем переменную, а именно функцию заточенную в ней, и получаем результат
# print(timein(one)())                        # Анологично будет записать так

# Так как функция one не принимает аргументов, можно было бы записать этот Декоратор как:
                                # Более понятный пример через функцию (НЕ ЯВЛЯЕТСЯ ДЕКОРАТОРОМ)
# def timein1(func):
#     start = datetime.now()
#     result = func()
#     print(datetime.now() - start)
#     return result
# print(timein1(one))

# Если функция должна принимать аргументы, то это выполняется следующим образом (работает для любой функции)

def timein(func):                              # Функция декоратора
    def wrapper(*args, **kwargs):                              # Его вложенная функция, которая и принимает аргументы оборачиваемой функции
        start = datetime.now()
        result = func(*args, **kwargs)                                # выполнение самой функции, которую мы оборачиваем декоратором
        print(datetime.now() - start)
        return result
    return wrapper
# print(timein(two)(10000))                                               # timein(two) аналогичен wrapper (в которой вместо 'func' стоит функция 'two') (wrapper(10000))
                                                                                                            # Однако это запись длинная и неудобная, поэтому...

@timein                             # Это краткая запись 'timein(three)(i)', теперь при вызове функции three(i), на самом деле будет вызываться 'timein(three)(n)'
def three(i):                                                                       # третья функция
    result = [(n*n*n*n*n*n*n*n*n*n)**10 for n in range(i) if n % 5 == 0]            # действия самой функции не так важны
    return result

# print(three(10000))                 # аналогично 'print(timein(three)(10000))' (но в таком случае нельзя указывать '@timein' )
# !!! Плохой неправильный пример !!!                                   иначе мы будем измерять скорость функции замерки другой функции (А это даже звучит бредово...)
# print(timein(three)(10000))               # При наличии '@timein' данная функция будет проделавать двойную работу (Замерять скорость замерки другой функцией другой функции)

# Декоратор может принимать свои аргументы и работать с ними
# Формально, для этого мы должны обернуть внутреннюю функцию декоратора ещё раз
def timein(arg):                                        # Сам Декоратор, который принимает аргумент
    print(arg)                                                      # манипуляции, которые проделывает сам декоратор со своими аргументами (в данном случае просто печатает)
    def outer(func):                                    #! Дополнительная вложенная функция, о которой сказанно выше
        def wrapper(*args, **kwargs):                              # Его вложенная функция, которая и принимает аргументы оборачиваемой функции
            start = datetime.now()
            result = func(*args, **kwargs)                                # выполнение самой функции, которую мы оборачиваем декоратором
            print(datetime.now() - start)
            return result
        return wrapper
    return outer
# !!! В таком случае, '@timein' перед нужной функцией должна быть заменина на '@timein(arg)'
@timein('Ты лох?')                                              # Пример такой замены
def three(i):
    result = ['ДА' for n in range(i) if n % 5 == 0]            # действия самой функции не так важны
    return result
# print(three(5000))

# Тоже самое можно записать так:
# result = timein('Ты лох?')(three)(5000) # 'timein('Ты лох?')' возвращает 'outer' [outer(three)(5000)], а 'outer(three)', в свою очередь, возвращает 'wrapper' [wrapper(5000)]
# print(result)                                                                               # Опять же, в данном случае '@timein('Ты лох?')' перед функцией НЕЛЬЗЯ указывать