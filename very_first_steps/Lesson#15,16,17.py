from functools import reduce                                # Для 15 строчки
# with open("15_123.txt") as f:
#     a = list(map(int, f))                          # map(function,element)   применяет функию для каждого элемента function - without"()"
#     print(a)                                    # map - хрень, надо разобраться
# b = filter(lambda a: a % 2 == 1, a)
# print(list(b))
def function(a,b):
    return a*b
result = map(function,[1,2,3,4,5,6],["a","b","c","d","e"])  # map можно использовать с нескольками списками и со своими def функциями (а также с lambda)
                                                                                    # (! "6" - не входит так как первый список большей длины )
# print(list(result))                                                 # !!! map выводит ответ в своём типе, поэтому его обязательно надо преобразовать в list or str or...

result = filter(lambda x: x % 2 != 0 ,range(0,15))   # filter() - как map только принимает только два аргумента и лучше подходит для фильтрации (map - выведет True/False)
# print(list(result))

result = reduce(lambda a,b: a*b, {15, 2, 5, 10, 4, 20 })        # reduce() - выполняет указанную функцию над всеми элементами множества, но выводит только однин результат
# print(result)

x_1 = [0,1,2,3,4,5,6,7,8,9]
x_3 = [10,11,12,13,14,15,16,17,18,19]
x_2 = "abcdefjhig"
result = zip(x_1,x_2,x_3)                   # zip() - групирует соответственные элементы первого множество с соответственными элементами второго множества
# print(list(result))                               # можно использовать более двух множеств НО! тогда невозможно создать словарь
# print(dict(zip(x_1,x_2)))                                 # dict() - преобразует в словарь (ZIP хорошо работает со словарями, объединяя всё в один словарь)

def summa(*args):                                 # "*args"("*" - is also possible) позволяет производить функцию над всеми элементами, которые будут введены
    print(args)                                                                                         # *args - записывает все данные в виде кортеджа
    print(sum(args))                                                                             # sum() - выводит сумму всех элементов
# summa(1,3,5,23,3,5,5,3,2,4,5,5,3,3,55,5,5,5,5,55,5,2,45,34,67,547,56,5,4,32,34,5,675,4)

def sweets(**sweets):                                                           # **kwargs - позволяет производить функцию над всеми элементами, но вводить надо с КЛЮЧОМ!
    print(sweets)                                                               # **kwargs (or just "**") - выводит данные в виде словаря
    for k, x in sweets.items():                                                 # !Сначала указывается ключ (k - ключ; x - значение)
        print(("{} : {}").format(k,x))
# sweets(t="toffee", c = "candy", p = "pie", i = "icecream", m = "marmalade")     # !Каждаму объекту функции должен соответствовать ключ



# spisok_True = []
# for i in range(1,21):                           # Это пример программы в 5 строк, программа ниже делает всё тоже самое, только в одну строку
#     if i % 2 != 0:
#         spisok_True.append(i)
# print(spisok_True)

# spisok_True = [i for i in range(21) if i % 2 != 0]          # - рабочий экземпляр, тоже самое, что и сверху но в одну строку
# spisok_error = [               i               ||                 for i in range(20)                    ||              if i % 2 != 0             ]     # НЕ РАБОЧИЙ
#                   Элемент, которым будет       || Цикл,показывающий сколько раз или из какого           ||    Условие, по которому происходит           #     ПРИМЕР
#                           заполняться список   ||          или из какого "множества" взят объект        ||                    сортировка в списке       # НЕ РАБОТАЕТ!!!
# print(spisok_True)
# print(sum({i**2 for i in range(51) if i % 5 == 0}))                                   # Возможно сократить до одной строчки (также сдесь использован кортедж "{}")
spisok = [(i,j) for i in range(24) for j in range(60) if j % 30 == 0]                   # Можно использовать больше одной переменной и цикла (получится цикл в цикле)
# print(spisok)
spisok = [i**2 if i < 0 else i**3       for i in range(-10,11)      if i % 2 != 0]
            # 3.И последним это        1.Первое выполняется это      2.Вторым это                   # Программа действует в таком порядке
# print(spisok)

s = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]
s = {i for i in s}; print(s)                                   # Удобный способ превращения списка в множество (НЕ ПОМЕЩАЕТ ДУБЛИКАТЫ!)
                                                                            # Работает как и со списком, только меняем скобки на "{}"

# dictionary = {i:input("Введите число: ") for i in range(10) }       # Всё тоже самое, что и со списком, только {} и вместо заполняющей переменной пишется ключ и его объект
# print(dictionary)                                   # Словарь заполняющий элементы вводом с клавы (НЕ ПОМЕЩАЕТ ДУБЛИКАТЫ! (если вместо range(10) какое-то множество ))
