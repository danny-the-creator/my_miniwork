# Фишка асинхронного программирования в использование времени ожидания программы для выполнения следующей части кода

# При работе мы часто сталкиваемся с функциями у которых большое время ожидания
# При стандартном ходе программы в эти моменты ничего не происходит и время тратится впустую
# Асинхронная программа же в этот момент времени перейдёт к выполнению следующей части кода, а потом вернётся к выполнению той части, где она остановилась

import asyncio
from time import sleep

async def parsing(site_name):                           # async - вид асинхронной функции
    for page in range(3):
        # sleep(1)                                        # имитация времени ожидания сайта
        await asyncio.sleep(1)                  # sleep(1) - не подходит для асинхронной функции так как исполняет работу
        print(site_name, page)                          # результат вывода этой функции - это другая функция, которую называют корутинной

func_list = [asyncio.ensure_future(parsing('Site_1')),                              # функции, которые мы будем использовать в асинхронном виде
             asyncio.ensure_future(parsing('Site_2')),                                  # ensure_future() - принимает только асинхронные функции
             asyncio.ensure_future(parsing('Site_3'))]

# Чтабы функции считались асинхронными, они должны имет запись 'async def' а также содержать аналоги некоторых неасинхронных функций (как у нас asyncio.sleep(1)) если они нужны
event_loop = asyncio.get_event_loop()                           # Здесь будет исполнятся наш асинхронный код
event_loop.run_until_complete(asyncio.gather(*func_list))       # передача функций в event loop и их исполнение
event_loop.close()                                              # Завершаем эту часть асинхронного кода

