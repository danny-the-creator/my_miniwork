# Имена переменных ищутся в областях видимости в следующем порядке:
# local scope (то место где нам и потребовалось найти это переменную)
# enclosing scope (то что между local или global, к примеру функция в которой была вызвана наша локальная функция)
# global (тело программы)
# builtins (програмная область видимости со всеми классами, операторами и тд)

# В принципе обращение происходит по стеку вызовов: то что последнее в стеке, будет рассмотренно первым, а что первое, то последним
                                                                                                        # (local - первое, builtins - последнее)

# !!! Важно !!! Проверка областей видимости на наличие переменной невсегда совпадает со стеком вызовов функций

# def a():
#     print(x)
# def b():
#     x = 31
#     a()                                              # Здесь будет выведена ошибка (т.к.) при проверке областей видимости функция а нет функции b (где и указан x)
# b()                                                               # Будет проверен local scope 'a', потом сразу global, и потом builtins (нигде нет x, поэтому ошибка)

# Поэтому стоит объявлять аргумент, и не парится на счёт областей видимости (также можно просто применить global так как через эту область видимости программа

# !!! Global не всегда может заменить nonlocal (к примеру если нам нужно ИЗМЕНИТЬ значение в функции, то global не поможет, так как питон дайдёт до первоначального
                                                                                # значения заданного в функции раньше, чем до НУЖНОГО ИЗМЕНЁННОГО значения в global scope)
# 'nonlocal' ищет переменную в enclosing scope, ближайшую к нашей локальной области видимости, однако саму локальную,
                                                                                                    # как и глобальную область видимости наш поиск не затрагивает

# Final Program
def final_program():
    ScopeDict = {'global' : []}
    def get(scope, arg):
        if arg in ScopeDict[scope]:
            return scope
        else:
            for k, v in ScopeDict.items():
                if scope in v:
                    return get(k, arg)
            return None
    for i in range(int(input())):
        command, scope, arg = input().split()
        if command == 'add' or command == 'create':
            if command == 'create':
                scope, arg = arg, scope         # если их поменять программа выглядит логичнее
                ScopeDict[arg] = []
            ScopeDict[scope].append(arg)
        elif command == 'get':
            print(get(scope, arg))

# final_program()