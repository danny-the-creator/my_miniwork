# Как происходит итерация объекта?
# У всех итерируемых объектов в Python есть свой итератор (объет перечислитель)
# При обращении к нему он выдаст следующий элемент итерируемого объекта, либо выдаст ОШИБКУ, если такого нет (мы дошли до конца объекта)

# iterator = iter([1,2,3])            # становится итератором объекта помещённого в него (конечно только если объект можно итерировать)
# print(next(iterator))               # будет выводить следующий элемент, пока список не иссякнет
# print(next(iterator))
# print(next(iterator))
# print(next(iterator))               # Выдаст ошибку 'StopIteration', так как следующего элемента после 3 не существует



# Именно так и работает цикл for

# for i in line:                      # Данная запись аналогична следующей:
#     print(i)
#
# iterator = iter(line)               # Данная запись аналогична записи сверху (и в принципе Python именно так и воспринимает запись сверху)

# while True:
#     try:
#         i = next(iterator)
#     except StopIteration:
#         break

# Можно создать свой итератор в класе
# Класс считается итератором, если у него есть функция __next__ (подчёркивание функции next (_) обязательно)


class my_range():                       # Моя копия range() написанная с 0, но она включает последний элемент и НЕ ВКЛЮЧАЕТ 0
    def __init__(self, end):
        self.end = end                  # Когда мы должны остановится (когда прервать итератор)
        self.count = 0                  # Начало отсчёта
    def __next__(self):
        self.count += 1                 # Прибавим и выведем следующий элемент
        if self.count <= self.end:
            return self.count
        raise StopIteration             # В случае если мы перешли за заданный конец, то будет поднята ошибка StopIteration

# x = my_range(2)                    # создаётся объект итератора
# print(next(x))                          # используется функция next
# print(next(x))
# print(next(x))                     # вызовет ошибку (так как мы перешли за предел)

# Однако чтобы наш итератор можно было использовать в цикле for нужно дописать функцию __iter__

class my_range():
    def __iter__(self):
        return self          # чаще всего мы возвращаем self, так как iter() должна возвращать экземпляр итератора (а итератором является наш класс)
                                     # Поэтому в 97% случаев нужно возвращать сам объект (тоесть: self)

    def __init__(self, end):
        self.end = end
        self.count = 0

    def __next__(self):
        self.count += 1
        if self.count <= self.end:
            return self.count
        raise StopIteration
pass
# for i in my_range(15):            # вот и всё прекрасно работает, в 10 строчек кода создана замена range(), который ОЧЕНЬ часто используется в цикле for
#     print(i)

# Если питон встречает внутри тела функции хоть одну функцию 'yield', то любой ПЕРЕМЕННОЙ, которой мы передадим вызов этой функции будет назначен тип 'generator'
# !!! Внимание: тип самой функции НЕ поменяется на 'generator', она и останется функцией, generator это класс ВЫЗОВА ФУНКЦИИ
                                                                # (разница почти как между классами и объектами этих классов, толька вместо класса - функция)

# Если внутри генератора будет retur, встретив его генератор закончит своё исполнение и брасит ошибку StopIteration И СООБЩЕНИЕ, указанное в return
# Генераторы имеют много возможностей использования, к примеру, чтобы не нагружать устройство перебирая большой список, а выводить новые элементы по мере их необходимости

def tabs():          # Вкладки
    for i in range(100000000000000000000000000000000000000000000000000000000000000000000000000):            # кол-во вкладок
        yield f'Вкладка №{i+1}'

# shop = tabs()                                   # shop - это объект генератора
# while True:                                     # Мы имеем дохрена вкладок, но каждому пользователю все вкадки не нужны, а прогрузка их будет занимать время
#     for n in range(10):                         # Поэтому, использую генератор, мы выводим лишь 10 из всех вкладок
#         print(next(shop))
#     if input('Желаете открыть дополнительные вкладки?\n').lower() not in ('yes', '+', 'yep', 'да', 'ага', ''):      # И задаём вопрос, нужны-ли пользователю доп-вкладки?
#         print('\nСпасибо за покупку!')
#         break                                                                                                                   # Если нет, завершаем цикл
#     print()                                                                                                                     # Если да, открываем следующие 10


# Program   !!!
class multifilter():
    '''Принимает несколько функци и фильтрует изходя из них'''
    def judge_half(self):
        # print(self.pos >= self.neg)
        return self.pos >= self.neg
    def judge_any(self):
        # print(self.pos >= 1)
        return self.pos >= 1
    def judge_all(self):
        # print(self.neg == 0)
        return self.neg == 0
    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterable = iterable
        self.judge = judge
        self.funcs = funcs
    def __iter__(self):
        for n in self.iterable:
            self.pos = 0
            self.neg = 0
            for i in self.funcs:
                if i(n) == True:
                    self.pos += 1
                else:
                    self.neg += 1
            if self.judge(self):
                yield n
pass

# Program_2
def primes():
    x = 2
    while True:
        control = True
        for i in range(2, int(x**0.5)+1):
            if x % i == 0:
                control = False
                continue
        if control == True:
            yield x
        x+=1
# z = primes()
# for i in range(100):
#     print(next(z))

# !!! Генераторы списка быстрее проще и эфективнее, чем аналог через новый список и append, однако их функционал ограничен
# Любой генератор списка можно записать ввиде обычного цикла с append, но далеко не каждый цикл с append можно превратить в генератор
                                                                # (! Особенно если во время одного из циклов нужно выполнить функцию или какой-то кусок кода !)

# !!! Если в генераторе указать круглые скобки, то мы получим генератор (уже вызванную функцию с yield) и сможем работать как с обычным генераторором
x = (x for x in range(10))
# print(x)
# print(next(x))
# print(next(x))