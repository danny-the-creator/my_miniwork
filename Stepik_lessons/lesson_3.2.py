# Строки, которые имеют вид r'...' называются сырыми, ото слова raw - сырой

# import re
# re.match()                      # Проверяет подоходит-ли начало строки под заданный шаблон



# ! Регулярные выражения !:
# '|' : используется, чтобы показать несколько возможных вариантов символов, может выбирать между одной групой символов и другой
# print(re.findall('text|string', 'textstring'))

# В [] можно перечислить элементы (без запятых) любой из этих элементов будет подходить (также можно перечислять элементы через '-' ([0-9]))
# В () можно заключить группу мета-символов (все другие мета-символы будут работать на них, как если бы они были обычным одиночным символом)
# print(re.search(r'(text)+', 'texttexttext'))            # Находит не первое слово 'text', а целую строку, так как там написан 'text' три раза, что удовлетворяет шаблон
# print(re.match('(text|string)+', 'textstringstring'))       # Также работает и с союзом или (|)
# match = re.match('((abcd)|(text|string)+)', 'abcd')
# print(match)        # можно оборачивать скобки в скобки, и действия будут выполняться по мере открытия скобок

# Метод '.groups()' показывает результат для всех скобок по очереди (В примере выше, сначала откроются внешние скобки, результатом пойска будет 'abcd',
                                                                                # потом откроются первые внутренние скобки, их результатом тоже будет строка 'abcd',
                                                                                        # В последнюю очередь будут открыты вторые внутренние скобки, их результатом будет None,
                                                                                                    # так как, наша строка не подходит шаблону вторых скобок )
# print(match.groups())
# print(match.group(1))                                                          # если указать индекс, то будет выведен результат именно теx скобок (! Функция отличается)


# . ^ $ * + ? { } [ ] ( ) \ |  -- ВСЕ МЕТА-СИМВОЛЫ
# \d : [0-9]
# \D : [^0-9]
# \s : [ \t\n\r\f\v]  -  пробельные символы
# \S : [^ \t\n\r\f\v]
# \w : [a-zA-Z0-9_]    -  буквы и цифры и _
# \W : [^a-zA-Z0-9_]

# *  : повторение символа (который шёл до мета-символа) от 0 до бесконечности        'a*'
# +  : повторение символа (который шёл до мета-символа) от 1 до бесконечности        'a+'
# ?  : нас интересует 0 или 1 вхождение символа (который шёл до мета-символа)        'a?'
# {} : в скобках указывается кол-во повторений, которое нас устраивает               'a{5, 7}


# Сырая строка всё равно не меняет мето символы (те, которые используют регулярные выражения), поэтому чтобы провести поиск '[', её всё равно придёться экранировать '\['
# !!! Python будет стараться найти самую длинную строку, подходящую под регулярное выражение (тоесть если мы укажем 'b+', то нам выдадут все 'b' идущиее подряд)
# НО если добавить к нашему регулярному выражению '?' ('b+?'), то Python будет искать наоборот наименьшую (самую короткую строку) подходящую под регулярное выражение

# print(re.findall('b+?', 'bbbbbbbbbbbbbb'))                                  # все 'b' будут взяты отдельно


# !!! Работа со скобками:
import re
pattern = r'(\w+)[- _:]\1'                  # \number - Очень полезная функция, она копирует результат поиска в указанной паре скобок (в нашем случае (\w+) это первая скобка,
                                                                                                                                                                # её мы и копируем)
                                                                        # Но мы не просто копируем шаблон, мы копируем тот текст, который был найден до этого по донному шаблону

string = 'text-text car car new_now'        # второе слово (\1) должно строго повторяться (поэтому пройдёт всё, кроме последнего)
print(re.match(pattern, string))            # тоже самое можно использовать и в sub и в search

print(re.findall(pattern, string))          # Здесь всё немного тяжелее, так как findall будет выводить только то, что в скобках
print(re.findall(r'((\w+)[- _:]\2)', string))          #    Придётся завернуть всё в скобку, а значит нужно ужу указать \2, так как первая скобка сместилась
                                                                                    # (Но всё равно Python выводит это через кортедж с результатами всех скобок (как метод .groups)

# Также в модуле re существуют своеобразные флажки (константы в модуле), их можно передать дополнительным аргументом в функцию, чтобы повлиять на её исполнение (что-то изменить)
# Таких констант много, поэтому искать их стоить по мере необходимости
# Пример
print(re.search('text', 'TEXT', re.IGNORECASE))             # В данном случае, добавив 3 аргументом константу (не забывать, что она из модуля re и это надо дописать)
                                                                                                                                            # мы проигноририровали размер шрифта
# Дополнительные флаги добавляются через '|'

# First Program
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     if len(re.findall('cat', line)) >= 2:
#         print(line)

# 2
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     if len(re.findall(r'\bcat\b', line)) >= 1:
#         print(line)

# 3
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     if bool(re.search(r'z...z', line)) == True:
#         print(line)

# 4
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     if bool(re.search(r'\\', line)) == True:
#         print(line)

# 5
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     if bool(re.search(r'\b(.+)\1\b', line)) == True:
#         print(line)

# 6
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     print(line.replace('human', 'computer'))

# 7
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     print(re.sub(r'\b[aA]+\b', r'argh', line, count=1))

#8
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     print(re.sub(r'(\w)(\w)(\w*)', r'\2\1\3', line))

#9
# import re
# import sys
# for line in sys.stdin:
#     line = line.rstrip()
#     print(re.sub(r'(\w)\1+', r'\1', line))

# 10
# import re
# import sys
# for line in sys.stdin:                                  #  Проверяет, является-ли введённое число в двоичной системе кратным 3
#     line = line.rstrip()
#     if bool(re.fullmatch('[01]+', line)) == True:
#         first = [i for i in line[::2] if i == '1']
#         second = [j for j in line[1::2] if j == '1']
#         if (len(first) - len(second)) % 3 == 0:
#             print(line)
#         # pattern = "^(0|(1(01*0)*1))*$"            # любое двоичное число, делящиеся на 3 будет иметь такой вид и подойдёт под такой шаблон